# Rats!

Where TypeScript doesn't save you, or doesn't do what you want.

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [Lossy type downcasting](#lossy-type-downcasting)
- [Infinity is not of type Infinity](#infinity-is-not-of-type-infinity)
- [Uninitialized self-reference not caught in IIFE](#uninitialized-self-reference-not-caught-in-iife)
- [Numbers permitted in string index type](#numbers-permitted-in-string-index-type)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Lossy type downcasting

[playground](https://www.typescriptlang.org/play/#code/DYUwLgBGBcEN4QIawHYFcC2AjEAnCAvhALzxKwCMhA3AFCiRqxxGlh0MQBuzSA-LADOYXAEsUAc0IkIaOrVEAzCAAouAOkQQAhMVJoUAExCLxIQwEp4tCLaShcYNZvVgA9gFUADl7wBhREEQFQsLaggAegiILDc3DG1aAiA)

```typescript
let t: { a: number } = { a: 1 };
let u: {} = t;
let v: { a?: string } = u;

if (v.a !== undefined) {
    alert(v.a.toUpperCase()); // boom!
}
```

This typechecks, but because TS does not require verification of downcast
value's shape, this code blows up.

## Infinity is not of type Infinity

[playground](https://www.typescriptlang.org/play/?ssl=1&ssc=1&pln=3&pc=25#code/C4TwDgpgBAkgdgMygXigRgOwA4DMaBM2AnDgGxpEb6k5GZn4XZkVZU12Ev45Vqa4CxFpWq16pRpVzkibMZwzdejAXkJYSs9uKWSmM1jsXK+aoZpHGJU5rPkchp1cwtamCmwZEPxXcjxmrhruoo56toZy1v4EKvzBwtqeEd72MXpxQYIhVikMaUaesYEuOUke4QXSPhnOCeWWyVX6NenFmaUN6hVhutV2RY4l8ea5zf2tg9Ed9WO91qltQ36do4lNlZORtbMB642hiwNRvib72T2bfXRL02dOF2VXR-lTp3VP3W55LTvtwzWlx+E1uJ12gLmG1ef0KM0hX3m12O7whqyhh1+2zhDxGwPGWzBqIB6MR0KxRP+K3OWWeIMJXmW8NJtO+BJujPun1ZSJh2KZuKBdPZKKpzJpXV5FM5Hz2PPJoJlaIlBxe0rusoR8sxio1yse2rVuvBJJV+IWbzFgoxRoZetNBslCrtJupjtV9I59rdeOFFthAu5Tp1LuJPqFbP9-K5cuDtq9rvF7vNyMtOKDHpFacDsczUcp6dzAG4AFAlgDGAHs4ABnYBQOAALlgiBQLYQAEs4B3QEWgA)

```typescript
type Inf = 178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123721178312789361972639173621978361987263912736123;

const n: Inf = Infinity;
```

The giant number on the RHS of `Inf` evaluates to `Infinity` in a JS
interpreter, so TS types `Inf` as `Infinity` (verify by hovering over the type
alias).

But the `Infinity` value is not assignable to a value of type `Inf` because the
`Infinity` value is a number type. Makes sense.

## Uninitialized self-reference not caught in IIFE

[playground](https://www.typescriptlang.org/play?#code/DYUwLgBAxgXBCGA7AnhAvBAFJglOgfNDrgNxA)

```typescript
let c: any = (() => c)();
```

TypeScript thinks `c` is in scope of the IIFE, but in fact is not initialized until after the IIFE
is evaluated. At runtime, this throws a reference error.

## Numbers permitted in string index type

[playground](https://www.typescriptlang.org/play?#code/MYewdgzgLgBAtgQwA4C4YG8DaBrN0BOAlmAOYC6eURpAvjALwYBQMMAjGgOScA0TNQA)

```typescript
const map: {[k: string]: string} = {
  1: '',
}
```

This typechecks, but `const map: {[k: number]: string} = {'one': ''}` wouldn't. The runtime types
are semantically correct because object properties are strings, but accepting a number where strings
are expected isn't desirable during development.
